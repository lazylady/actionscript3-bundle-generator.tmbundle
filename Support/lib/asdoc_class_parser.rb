require ENV['TM_SUPPORT_PATH'] + '/lib/exit_codes'
require ENV['TM_BUNDLE_SUPPORT'] + '/lib/asdoc_tidy'
require ENV['TM_BUNDLE_SUPPORT'] + '/lib/list_to_regexp'

require 'rubygems'
require 'nokogiri'
require 'fileutils'

# A Utilty class to convert ActionScript class documentation
# generated by the asdoc command line tool into formats used
# by TextMate - tmLanguage, tmPreferences etc.
#
class AsdocClassParser

  CLASS              = "Class"
  CONSTANT           = "Constant"
  METHOD             = "Method"
  PROPERTY           = "Property"
  PROTECTED_METHOD   = "ProtectedMethod"
  PROTECTED_PROPERTY = "ProtectedProperty"

  # Generate Intrinsic classes
  private

    def initialize

      # The framework we are creating files for.
      @framework = "actionscript-framework"

      # Array to collect the class names of the documents we parse.
      @class_names = []

      # Array in which we collect public and protected methods
      # including their signatures.
      @method_completions = []

      # Arrays to collect all of the names of class elements.
      @method_names = []
      @protected_method_names = []
      @constant_names = []
      @property_names = []
      @protected_properties = []
      
      @logging_enabled = false

    end

    # Constructs and returns the xpath query for extracting
    # class element names of the type specified in id.
    def x_path(id)

      xpath_a = "//div[@class='summarySection']/table[@id='summaryTable"

      # Valid for properties and constants.
      xpath_b = "']/tr/td[@class='summaryTableSignatureCol']/a[@class='signatureLink']"

      if id =~ /Method/
        # Valid only for methods.
        xpath_b = "']/tr/td[@class='summaryTableSignatureCol']/div/a[@class='signatureLink']"
      end
      result = xpath_a + id + xpath_b
    end

    # Constructs and returns the xpath query for extracting
    # method names and signatures of the type specified in id.
    def x_path_method(id)
      xpath_a = "//div[@class='summarySection']/table[@id='summaryTable"
      xpath_b = "']/tr/td[@class='summaryTableSignatureCol']/div[@class='summarySignature']"
      result = xpath_a + id + xpath_b
    end

    # Scans the html for all the class elements of id type and
    # stores them in the specified array.
    def add_as_element(html,id,arr)
      html.xpath(x_path(id)).each() do |tag|
        arr.push( tag.text )
      end
    end

    # Scans the html for all method completions and converts them
    # to the format used by the Function Completion TM command.
    def gen_method_completions(html,id)
      html.xpath(x_path_method(id)).each() do |tag|
        # puts "Generate method with completion is a tag #{tag.text}"
        
        completion = tag.text.gsub(/\s/,"")            #Strip all whitespace.
        completion = tag.text.gsub(/ \302\240/,"")     #Strip strange dots "    " and mysterious white space
        completion = completion.gsub(/<\/?[^>]*>/,"")  #Strip html tags.
        completion = completion.sub(/\).*/,")")        #Strip return statement.
        
        #Only add completions with method params
        if completion =~ /^\w+\(\s*(\w+|\.\.\.)/
          # puts "completion : #{completion}"
          @method_completions << completion
        end
      end
    end

  public

    # Getter/Setters
    attr_accessor :base_path
    attr_accessor :id
    
    # The framework we are currenlty working with.
    def framework=(fw)
      @framework = fw
    end

    def logging_enabled=(boo)
      @logging_enabled = boo
    end
        
    # Input Commands

    # Load All Framework Classes
    def load_classes class_path_list
      class_path_list.each do |path|
        add_class path
      end
    end

    # Parses and stores the data found in the 'file_path'
    # to our internal lists.
    def add_class file_path
      
      if File.exist?(file_path)
        
        f = File.open(file_path)
        class_html = Nokogiri::HTML(f)
        class_name = File.basename( file_path, ".html" )
        
        @class_names.push(class_name)
        add_as_element(class_html,METHOD,@method_names)
        add_as_element(class_html,PROTECTED_METHOD,@protected_method_names)
        add_as_element(class_html,CONSTANT,@constant_names)
        add_as_element(class_html,PROPERTY,@property_names)
        add_as_element(class_html,PROTECTED_PROPERTY,@protected_properties)
        
        gen_method_completions(class_html,METHOD)
        gen_method_completions(class_html,PROTECTED_METHOD)
        
        f.close
      end
    end

    # Ouput Commands

    # Returns accumulated method completions.
    def method_completions

      return if @method_completions.empty?
      @method_completions.uniq.sort

    end

    # Returns all collected data as a tmLanguage file (plist format).
    def framework_language

      lang = "{"
      lang += "fileTypes = (as);"
      lang += "\tcomment = '#{@framework.capitalize} Framework.';\n"
      lang += "\tfoldingStartMarker = '\{\s*$';\n"
      lang += "\tfoldingStopMarker = '^\s*\}';\n"
      lang += "keyEquivalent = \"^~A\";"
      lang += "name = #{@framework.capitalize};\n"
      lang += "scopeName = 'source.actionscript.3.#{@framework}';\n"
      lang += "\tpatterns = (\n"

      all_elements = { "support.class" => @class_names,
                       "support.function" => @method_names,
                       "support.function.protected" => @protected_method_names,
                       "support.constant" => @constant_names,
                       "support.property" => @property_names,
                       "support.property.protected" => @protected_properties }

      all_elements.each do |key, value|

        next if value.empty?

        lang += "\t{\n"
        lang += "\t\tname = '#{key}.#{@framework}';\n"
        lang += "\t\tmatch = '\\b"
        lang += ListToRegexp.process_list(value.sort.uniq)
        lang += "\\b';\n"
        lang += "\t},\n"

      end

      lang += ");\nuuid = '" + `uuidgen`.chomp + "'; }"

    end

    # Returns collected data as a completions list.
    def auto_completions

      comps =	 "{ name = 'Completions';\n"
      comps += "scope = 'source.actionscript.3';"
      comps += "settings = "
      comps += "{\n\tcomment = '#{@framework} completion list';"
      comps += "\n\tcompletions = ("

      elements =	@class_names +
        @method_names +
        @protected_method_names +
        @constant_names +
        @property_names +
        @protected_properties

      elements = elements.uniq.sort

      elements.each do | item |
        comps += "'" + item + "'"
        comps += "," if item != elements.last
      end

      comps += ");\n};\nuuid = '" + `uuidgen`.chomp + "'; };\n}"

    end

    # Returns a list of accumulated method names.
    def method_names
      return if @method_names.empty?
      @method_names.uniq.sort
    end

    # Returns a list of accumulated class names.
    def class_names
      return if @class_names.empty?
      @class_names.uniq.sort
    end

    # Returns a list of accumulated constant names.
    def constant_names
      return if @constant_names.empty?
      @constant_names.uniq.sort
    end

    # Returns a list of accumulated constant names.
    def property_names
      return if @property_names.empty?
      @property_names.uniq.sort
    end

    # Log output.
    def log( message )
      if @logging_enabled

        require 'syslog'

        Syslog.open('as3-bundle-gen')
        Syslog.crit(message)
        Syslog.close()

      end
    end

end
